# Файлы и системные вызовы (lab2)

## Теоретические вопросы

1. Системные вызовы и механизм их работы.
1. Что такое файл? Чем отличается файл от директории?
1. Что такое `inode` и `dentry`? Их основные поля и зачем они нужны?
1. Символьные и жесткие ссылки и инструменты для их создания (`symlink(2)` и `link(2)`).
1. Что выводит утилита `strace`? Используйте её вместе с библиотекой для времени, объясните что происходит.
1. Зачем нужно `vdso`?
1. Что такое файловая система?
1. Утилиты `mount` и `unmount`. Что они делают и зачем нужны?
1. Что такое переменные окружения? зачем они нужны? как их использовать?
1. В чём различие между `interrupt`, `syscall`, `sysenter`?


## Задания (порядок выполнения не важен)

1. Логгер:
    1. Реализуйте динамическую библиотеку логгера с описанным ниже интерфейсом.
    Сообщение логгера должно иметь следующую сигнатуру: "TIME(UTC) FILE LINE [PID] | LEVEL: MESSAGE". Время выводится в формате
    ```%d-%d-%dT%d:%d:%d(%s){year, month, day, hours, minutes, seconds, timezone}```

1. Конфиг:
    1. Реализуйте статическую библиотеку системы конфигурации с указанным ниже интерфейсом.
        При реализации учтите возможные способы передачи пути к файлу с конфигурацией (см. раздел "Команды для запуска
        и окружение"). Если путь к файлу с конфигурацией не был передан ни одним из способов, то ищите файл с
        конфигурацией в корневой директории проекта (он должен называться `proxy.conf`). Если по этому пути файла не оказалось,
        то используйте стандартные значения для необходимых переменных.
    1. Конфиг должен поддерживать параметры, указанные в разделе "Параметры конфигурации".
    1. Должна быть выстроена система приоритетов: Файл конфигурации < Переменная окружения < Флаг командной строки.
        Значения параметров из источника с большим приоритетом перекрывают значения из источника с меньшим приоритетом. Например,
        одна и та же переменная задана из файла конфигурации и из флага при запуске, тогда значение будет взято из опции, поскольку
        флаг имеет больший приоритет.
    1. Используйте логгер для вывода сообщений об ошибках и прохождении важных точек программы, таких как чтение файла конфигурации.

1. Время:
    1. Реализуйте статическую библиотеку для времени с указанным ниже интерфейсом. Для этого используйте системный вызов `time(2)`.
    1. Используйте получившуюся библиотечную функцию в логгере для получения времени.

1. Версионирование библиотеки для времени:
    1. Сохраните текущую версию библиотеки для времени и напишите новую реализацию, использующую свою обёртку над
        системным вызовом time (используйте `syscall(2)` из libc).
    1. Сделайте ещё одну реализацию этой библиотеки. Для этого разберитесь как работает `syscall(2)` и
        сделайте системный вызов без его помощи (используйте ассемблерные вставки).
    1. Для переключения между этими реализациями используйте символьные ссылки (файл библиотеки с названием libtime.so
        должен быть символьной ссылкой на одну из версий библиотеки).

1. Модифицируйте систему загрузки плагинов из первой лабораторной
  1. Она должна загружать плагины, названия которых ей переданы через параметр `plugins` файл конфигурации или
  переменную окружения `PROXY_MASTER_PLUGINS` (см. раздел "Команды для запуска и окружение")
  1. При загрузке плагина должно быть выведено соответствующее [сообщение](#ведение-журнала)

1. Режим отладки
    1. Реализуйте отладочный режим работы программы. В этом режиме вне зависимости от заданной конфигурации все логи выводятся в stdout.
    Чтобы запустить отладочный режим программа должна быть запущена через файл с именем `debug_proxy`.

## Ожидаемое поведение программы

1. При реализации учтите возможные способы передачи пути к файлу с логами (см. раздел "Команды для запуска
    и окружение"). Если путь к файлу с логами не был передан ни одним из способов, то используйте stderr для вывода сообщений.
1. Если программа запущена через жёсткую ссылку "proxy", то запускается обычная версия программы. Если же используется ссылка "debug_proxy",
   то запускается режим отладки (смотрите пункт "Режим отладки" [задания](#задания-порядок-выполнения-не-важен) ) 
### Ведение журнала
1. При успешном открытии файла конфигурации: <br> <code>INFO "Start read config file %s", ${путь_до_файла_конфигурации}</code>
1. При успешном завершении чтения файла конфигурации:<br> <code>"Finish read config file %s", ${путь_до_файла_конфигурации}</code>
1. При загрузке плагина:<br> <code>INFO "Plugin %s loaded", ${имя_плагина}</code>

### Обработка ошибок

1. Вывод ошибок после которых программа продолжает работу должен направляться в лог с уровнем сообщения `ERROR`.
1. Вывод ошибок после которых программа должна немедленно завершить работу должен направляться в лог с уровнем сообщения `FATAL`.
1. Отсутствие прав доступа к файлу(например файлу журналов):<br> <code>"Have no permissions for file %s", ${путь_до_файла}</code>
1. Файл конфигурации не найден по заданному пути: сообщение<br> <code>"File %s not found", ${ошибочный_путь_до_файла_конфигурации}</code><br> должны быть проинициализированы стандартные значения или значения из других источников (например флага командной строки), если такие существуют
1. В файле конфигурации синтаксическая ошибка: сообщение<br> <code>"Configuration file %s has syntax error at %d: %s", ${путь_до_файла, номер_строки_ошибки, строка_с_ошибкой}</code><br>, после этого переход к следующей строке файла конфигурации.


## Команды для запуска и окружение

Источники значений для параметров конфигурации:

Передача пути к файлу с конфигурацией возможна двумя способами:
1. Через флаг `-c` при запуске. (длинная версия `--config`)
2. Через переменную окружения `PROXY_CONFIG_PATH`

Передача пути к файлу логов возможна двумя способами:
1. Через флаг `-l` при запуске. (длинная версия `--logs`)
1. Через переменную окружения `PROXY_LOG_PATH`

Передача списка плагинов для загрузки возможна двумя способами:
1. Через переменную `plugins` в файле конфигурации
1. Через переменную окружения `PROXY_MASTER_PLUGINS` (разделителем между названиями выступает запятая)


Команда для запуска:
```
pwd/install/proxy -c path_to_config_file -l path_to_log_dir
```
Флаги командной строки могут идти в любом порядке и являются опциональными


## Конфигурационные параметры

```
log_file_size_limit = 1024 # Максимальный размер лог файла в Kb
logs = "logs" # Путь до файла логов от текущей рабочей директории
plugins = ["test", "task_manager"] # Список плагинов
```

## Интерфейс и структура проекта


### Файл my_time.h

#### Функции:

| Название     | Описание                 | Аргументы | Возвращаемое значение                    |
| :----------- | :----------------------- | :-------- | :--------------------------------------- |
| **get_time** | Возвращает текущее время | **void**  | **time_t**, текущее время в UNIX формате |


### Файл logger.h

#### Общие замечания:

Этот файл содержит сигнатуры функций `logger`.

Логгер - это синглтон. Поэтому вызов функции `init_logger` при созданном логгере и вызов `fini_logger` при уничтоженном
логгере должны возвращать значение -1.

Логгер должен уметь записывать сообщения в некоторые выходные потоки, которые
перечисляются в `OutputStream`:

1. STDOUT
1. STDERR - стандартный поток для ведения log. Регистратор должен использовать этот поток
    если выбранный поток недоступен.
1. FILESTREAM - логгер может использовать этот поток, если параметр path в
    вызове `init_logger` не равен NULL.

В указанном файле журналирования должны записываться все логи с потоком `FILESTREAM`.
Если через параметр конфигурации `log_file_size_limit` задано ограничение на размер файла,
и новая запись не помещается в журнал, то файл должен быть очищен и запись должна быть
помещена в начало этого файла.

#### Типы:

| Название типа    | метатип  | состав                                                                                         |
| :--------------- | :------- | :--------------------------------------------------------------------------------------------- |
| **LogLevel**     | **enum** | **LOG_DEBUG** = 1<br>  **LOG_INFO**<br>  **LOG_WARNING**<br>  **LOG_ERROR**<br>  **LOG_FATAL** |
| **OutputStream** | **enum** | **STDOUT** = 1<br> **STDERR**<br> **FILESTREAM**                                               |


#### Функции:

<table>
    <thead>
        <tr>
            <th>Название</th>
            <th>Описание</th>
            <th>Аргументы</th>
            <th>Возвращаемое значение</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>init_logger</b></td>
            <td>Инициализирует логгер (его структуры данных)</td>
            <td>
                <b>[in] char* path</b> Путь до файла журнала от текущей рабочей директории. Может быть NULL, но тогда режим журналирования FILE будет не доступен<br>
                <b>[in] int file_size_limit</b> максимальный размер файла журнала в Кб (-1 означает бесконечность)<br>
            </td>
            <td><b>int</b>, 0 в случае успеха, -1 иначе</td>
        </tr>
        <tr>
            <td><b>fini_logger</b></td>
            <td>Освобождает все захваченные ресурсы логгером</td>
            <td><b>void</b></td>
            <td><b>int</b>, 0 в случае успеха, -1 если ресурсы логгера уже были освобождены</td>
        </tr>
        <tr>
            <td><b>write_log</b></td>
            <td>Пишет сообщение в журнал</td>
            <td>
                <b>[in] OutputStream stream</b> тип потока журналирования<br>
                <b>[in] LogLevel level</b> уровень сообщения<br>
                <b>[in] char* filename</b> имя файла из которого был вызов функции<br>
                <b>[in] int line_number</b> номер строки из которой был вызов<br>
                <b>[in] char* format</b> форматированная по правилам printf строка<br>
                <b>[in] ...</b> вариадический список аргументов форматированной строки
            </td>
            <td><b>void</b></td>
        </tr>
    </tbody>
</table>


### Файл config.h

#### Общие замечания:

Этот файл содержит сигнатуры функций конфигурации и определения типов.

Config - это синглтон. Следовательно, вызов функции `create_config_table` при созданном конфиге и вызов `destroy_config_table`
при отсутствии конфига должны возвращать -1.

Конфигурационный файл представляет собой набор пар ключ-значение в формате: `ключ = значение` ( количество пробелов
и их расположение относительно несущественных могут быть любыми)

Ключ должен состоять из следующих символов: A-Z, a-z, 0-9, _, - и его длина должна быть <= 127.

Значение должно быть одного из следующих типов:
1. `INTEGER` - целое число со знаком и размером 64 бита;
1. `REAL` - число с плавающей запятой и двойной точностью;
1. `STRING` - константная строка в стиле C.

И массив из этих типов в формате: `массив = [значение, значение, ..., значение]`. Один массив может содержать
значения только одного типа.

Также строка конфигурации может содержать однострочный комментарий, начинающийся с `#`. Комментарий может начинаться в произвольном
месте строки.

Имя файла конфигурации по умолчанию: `proxy.conf`, он хранится в корневом каталоге проекта. Если файл конфигурации указан в строке
запуска через флаг `-c`, то будет использован заданный файл вместо файла по умолчанию.

#### Типы:

<table>
  <thead>
    <tr>
      <th>Название типа</th>
      <th>метатип</th>
      <th>состав</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>ConfigData</b></td>
      <td><b>union</b></td>
      <td>
        <b>int64_t* integer</b><br>
        <b>double* real</b><br>
        <b>char** string</b>
      </td>
    </tr>
    <tr>
      <td ><b>ConfigVarType</b></td>
      <td ><b>enum</b></td>
      <td >
        <b>UNDEFINED</b> = 0<br>
        <b>INTEGER</b> = 1<br>
        <b>REAL</b><br>
        <b>STRING</b>
      </td>
    </tr>
    <tr>
      <td ><b>ConfigVariable</b></td>
      <td ><b>struct</b></td>
      <td >
        <b>char* name</b><br>
        <b>char* description</b><br>
        <b>ConfigData data</b> значение переменной. Может быть как массивом, так и одиночным значением. Надо смотреть count, чтобы понять точно.<br>
        <b>ConfigVarType type</b> тип. Если UNDEFINED, значит произошла ошибка и другие поля не имеют смысла.<br>
        <b>int count</b> количество аргументов.
      </td>
    </tr>
  </tbody>
</table>


#### Функции:

<table>
  <thead>
    <tr>
      <th>Название</th>
      <th>Описание</th>
      <th>Аргументы</th>
      <th>Возвращаемое значение</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>create_config_table</b></td>
      <td>Инициализирует структуры данных системы конфигурации</td>
      <td><b>void</b></td>
      <td><b>int</b>, -1 если система уже проинициализирована или произошла ошибка, 0 в случае успеха</td>
    </tr>
    <tr>
      <td><b>destroy_config_table</b></td>
      <td>Освобождает все ресурсы, используемые системой конфигурации</td>
      <td><b>void</b></td>
      <td><b>int</b>, -1 если система уже освободила ресурсы или произошла ошибка, 0 в случае успеха</td>
    </tr>
    <tr>
      <td><b>parse_config</b></td>
      <td>Считывает параметры конфигурации из файла</td>
      <td><b>[in]const char* path</b> путь до файла конфигурации от текущей рабочей директории. Не может иметь значение NULL.</td>
      <td><b>int</b>, 0 в случае успеха, -1 если произошла ошибка</td>
    </tr>
    <tr>
      <td><b>define_variable</b></td>
      <td>Регистрирует новую переменную конфигурации</td>
      <td><b>[in]const ConfigVariable variable</b> инициализирующая структура</td>
      <td><b>int</b>, 0 в случае успеха, -1 если произошла ошибка</td>
    </tr>
    <tr>
      <td ><b>get_variable</b></td>
      <td >Берет значение переменной из системы конфигурации по имени</td>
      <td ><b>[in]const char* name</b> имя переменной</td>
      <td ><b>ConfigVariable</b> значение переменной в случае успеха или структуру с типом UNDEFINED в случае ошибки</td>
    </tr>
    <tr>
      <td><b>set_variable</b></td>
      <td>Устанавливает значение переменной. Если переменная не зарегистрирована, то создаёт переменную с таким именем и заполняет значение</td>
      <td><b>[in]const ConfigVariable variable</b> новое значение переменной</td>
      <td><b>int</b>, 0 в случае успеха, -1 если произошла ошибка</td>
    </tr>
    <tr>
      <td><b>does_variable_exist</b></td>
      <td>Определяет зарегистрирована ли переменная с данным именем</td>
      <td><b>[in]const char* name</b> проверяемое имя</td>
      <td><b>bool</b>, true если существует, false иначе</td>
    </tr>
  </tbody>
</table>
