# Межпроцессное взаимодействие (lab4)

## Теоретические вопросы

1. Какие бывают способы межпроцесного взаимодействия (IPC)?
2. Где можно выделять разделяемую память? Что и когда лучше?
3. Какие проблемы есть у метода разделяемой памяти?
4. Что такое пайп, как он устроен?
5. Что такое сокет Беркли?
6. Процесс установления связи доменных сокетов.
7. В чём различие потоковой и датаграммной передачи данных?
8. Блокирующие и неблокирующие сокеты в чём различие?
9. Мультиплексор. Что это и зачем используется?

## Задания
К текущему моменту был разработан мастер-модуль, способный во время исполнения подключать библиотеки и запускать дочерние процессы. Также были разработаны 2 плагина, один из которых, task_manager, может по сигналу sighup создавать дочерний процесс и запускать в нём программу, заданную параметром конфигурации.

Цель текущей лабораторной работы - изучение механизмов межпроцессного взаимодействия. Для её достижения вам предлагается преобразовать текущий плагин task_manager в сервер, работающий на unix domain sockets, а также клиент (отдельная программа), через который можно было бы посылать команды запуска различных программ.

1. **my_popen**
   1. Реализуйте собственную библиотеку my_popen.a c заданным [интерфейсом](#файл-my_popenh).
1. **Сервер**
   1. Реализуйте сервер на доменных юникс сокетах. Сокет подключения должен находиться в корневой директории проекта и называться "connection_socket". Сервер должен быть способным поддерживать одновременно несколько сессий (с различными клиентами), при этом использоваться должен один процесс (используйте подходящий для задачи мультиплексор  из списка: select, poll, epoll). Определите максимальное число одновременно поддерживаемых клиентов и установите его через [параметр конфигурации](#конфигурационные-параметры)  Сервер должен поддерживать заданный [протокол](#протокол-взаимодействия).
1. **Клиент**
   1. Реализуйте клиент на доменных юникс сокетах. Клиент должен поддерживать заданный [протокол](#протокол-взаимодействия).


## Протокол взаимодействия
Сначала клиент подключается к серверу по доменному сокету подключения (читайте задание, раздел "Сервер").

Клиент может посылать серверу 3 типа команд: ```RUN```, ```INPUT```, ```EXIT```. Все команды начинаются с одного из этих трёх слов.
1. <b>RUN</b> в аргументах через пробел указывается путь до запускаемой программы (или её имя, если путь известен) и аргументы, формат оформления аргументов как в командной строке. Пример:
    ```C
    RUN echo Hello!//Здесь программа "echo" и единственный аргумент "Hello!"
    ```
1. <b>INPUT</b> последующая строка, после одного пробела считается значением, которое будет отправлено в stdin запущенной программы. Пример:
    ```C
    INPUT  To be, or not to be: that is the question //Здесь значением будет строка " To be, or not to be: that is the question ".
    ```
1. <b>EXIT</b> Данная команда завершает сессию и завершает работу клиента. Сервер должен очистить ресурсы связанные с сессией

Сервер может посылать ответы с четырьмя тегами: ```OUTPUT```, ```ERROR```, ```RETURN```, ```ABORT```. Все ответы начинаются с оного из этих слов.
1. <b>OUTPUT</b> последующая строка, после одного пробела, есть значение, полученное в stdout. Пример:
    ```C
    OUTPUT Answer is 42//Здесь значением будет строка "Answer is 42"
    ```
2. <b>ERROR</b> последующая строка, после одного пробела, есть значение, полученное в stderr. Пример:
    ```C
    ERROR Out of memory//Здесь значением будет строка "Out of memory"
    ```
3. <b>RETURN</b> последующая строка, после одного пробела, есть код возрата программы, если это код возврата, либо указывается номер сигнала по которому остановлен / завершён процесс. Примеры оформления этих сообщений:
    ```C
    RETURN 0//Код возврата программы равен 0
    RETURN Terminated by signal 11//процесс завершён сигналом sigsegv
    RETURN Stopped by signal 19//процесс остановлен сигналом sigstop
    ```
4. <b>ABORT</b> Данное сообщение посылается сервером в случае завершения работы или невозможности выполнения команды (например не хватает файловых дескрипторов), оно завершает сессию и завершает работу клиента. Сервер должен очистить ресурсы связанные с сессией.

> [!NOTE]
> Будьте осторожнее с пробелами в начале и конце строк которые посылаете через команды `INPUT` / `OUTPUT` / `ERROR`

## Ожидаемое поведение программы

1. При инициализации мастер процесс запускает дочерний процесс с основной функцией из плагина task_manager. Дочерний процесс создаёт сокет, начинает его прослушивать.
1. При подключении нового клиента, сервер должен продолжать поддерживать старые сессии и быть способным создавать новые.
1. При команде `RUN` от клиента сервер должен проверить, что у него достаточно ресурсов и число клиентов не превышено, в случае неудачи, отправить сообщение `ABORT` и завершить только данную сессию.
1. В случае успеха при команде `RUN`, сервер должен воспользоваться функцией [my_popen](#функции) и запустить заданную клиентом программу. При этом весь выход из stdout и stderr должен быть перенаправлен клиенту в ответах `OUTPUT` и `ERROR`, а все команды INPUT должны быть отправлены в stdin дочернего процесса.
1. При завершении работы дочернего процесса, сервер должен закрыть пайпы, взять код возврата (или сообщение о сигнале) и в соответствии с [протоколом](#протокол-взаимодействия) отправить его клиенту в ответе `RETURN`. Далее ожидать команд от клиента.
1. При завершении работы по сигналу (например sigint) сервер должен корректно остановить все дочерние процессы, закрыть пайпы и остановить сессии с сообщениями `ABORT`, после чего корректно завершить работу.

> [!TIP]
> Как синхронно завершить работу, если сигнал приходит асинхронно?
>
> Используйте **дополнительный пайп**, один конец которого прослушивайте через мультиплексор.
> В случае пришедшего сигнала завершения работы в обработчике сигнала отправьте сообщение о пришедшем сигнале на конец пайпа,
> который не прослушивается, тогда потом вы сможете в синхронном режиме увидеть данное сообщение при помощи мультиплексора
> и синхронно корректно освободить ресурсы, закрыть сессии и завершить работу!


### Сообщения task_manager
1. Если дочерний процесс завершился с определённым кодом возврата:
    ```C
    "Child process %d finished with code: %d\n", ${pid}, ${код_завершения}
    ```
1. Если дочерний процесс был остановлен по сигналу:
    ```C
    "Child process %d stopped by signal: %d\n", ${pid}, ${номер_сигнала}
    ```
1. Если дочерний процесс был завершён по сигналу:
    ```C
    "Child process %d terminated by signal: %d\n", ${pid}, ${номер_сигнала}
    ```

### Обработка ошибок

1. Если при получении команды `RUN` у **сервера не получилось создать новый процесс** то необходимо написать в лог сообщение с уровнем `LOG_WARNING`:
    ```C
    "Can not run command %s in session with file descriptor %d\n", ${команда переданная в RUN, номер файлового дескриптора сокета из текущей сессии}
    ```
    После этого отправить клиенту сообщение `ABORT`, завершить текущую сессию, очистить связанные с ней ресурсы
1. Если **сервер получил некорректную команду**, сервер должен написать в лог сообщение с уровнем `LOG_WARNING`:
    ```C
    "Incorrect command %s in session with file descriptor %d\n", ${команда полученная от клиента, номер файлового дескриптора сокета из текущей сессии}
    ```
    После этого отправить клиенту сообщение `ABORT`, завершить текущую сессию, очистить связанные с ней ресурсы
1. Если **клиент получил некорректный по структуре ответ** от сервера, то он должен отправить `EXIT`, закрыть сокет, завершить работу.

### Журнал сообщений

1. При начале прослушивания сокета сервер должен написать в лог сообщение с уровнем `LOG_INFO`:
    ```C
    "The server started listening to the connection socket\n"
    ```
1. При установлении нового соединения сервер должен написать в лог сообщение с уровнем `LOG_INFO`:
    ```C
    "The server started new session. File descriptor is %d\n", ${номер файлового дескриптора нового сокета}
    ```
1. При завершении сессии с клиентом сервер должен написать в лог сообщение с уровнем `LOG_INFO`:
    ```C
    "The server finished session. File descriptor is %d\n", ${номер файлового дескриптора закрытого сокета}
    ```

## Конфигурационные параметры

```
max_client_supported = 42 # Максимальное число поддерживаемых клиентов одновременно
```

## Требования к устойчивости

Все ресурсы при завершении должны корректно освобождаться (в том числе при сбоях в работе),
дочерние процессы должны восстанавливаться если это необходимо, должна быть корректная обработка сигналов.

## Интерфейс и структура проекта

### Файл my_popen.h

#### Функции:

<table>
    <thead>
        <tr>
            <th>Название</th>
            <th>Описание</th>
            <th>Аргументы</th>
            <th>Возвращаемое значение</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>my_popen</b></td>
            <td>Создаёт 3 пайпа (для stdin, stdout, stderr), после чего делает форк, подменяет stdin, stdout, stderr на файловые дескрипторы пайпов, а потом запускает  заданную команду с заданными аргументами и переменными окружения</td>
            <td>
                <b>[in] const char* command</b> Команда (например "cat"). Не может быть NULL<br>
                <b>[in] char* const argv[]</b> Массив строковых аргументов запуска<br>
                <b>[in] char* const envp[]</b> Массив переменных окружения<br>
                <b>[out] int pipes[3]</b> Массив, в котором будут указаны фаловые дескрипторы в порядке: stdin, stdout, stderr<br>
                <b>[out] int *child</b> Указатель на int в который будет записан pid дочернего процесса<br>
            </td>
            <td><b>int</b>, 0 в случае успеха, 1 иначе</td>
        </tr>
        <tr>
            <td><b>my_pclose</b></td>
            <td>Закрывает пайпы, ожидает завершения дочернего процесса, ассоциированного с ними. Возвращает результат работы программы как waitpid</td>
            <td><b>int pid</b> pid дочернего процесса</td>
            <td><b>int</b>, код возврата программы</td>
        </tr>
    </tbody>
</table>