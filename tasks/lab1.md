# Компиляция и линковка (lab1)

## Теоретические вопросы
    1. Из каких этапов состоит компиляция (используйет флаги компилятора и посмотрите промежуточные результаты)?
    2. Что такое elf файл и какие его типы бывают?
    3. Используйте readelf. Посмотрите основные секции elf файла и их назначение.
    4. Статические и динамические библиотеки. Чем отличаются relocateable и shared object файлы.
    5. Как именно происходит подключение символов из динамической библиотеки (секции got, plt).
    6. Различие статической и динамической линковки (посмотрите dlopen и dlsym).
    7. nm и ldd, с какимии секциями elf файла работают? Объяснить вывод.
    8. Что делает утилита file. Объяснить её вывод.
    9. Чем отличаются секции от сегментов?
    10. Посмотрите зависимости собранного исполняемого файла. Зачем нужен ld-linux.so (секция .interp)?
    11. Зачем может понадобиться утилита strip и objdump?
    12. Как запускается main функция программы?
    13. Зачем нужен флаг компиляции -export-dynamic
    14. При помощи nm посмотрите все символы получившегося исполняемого файла. Как настроить компоновщик, чтобы сохранились
        все символы, предоставляемые библиотекой config?

## Список литературы: //todo
    1. "Практический анализ двоичных файлов" Дэннис Эндриесс

## Задания (порядок выполнения не важен)
    1. Система плагинов:
        a. Напишите тестовый плагин с именем "greeting" в соответсвии с представленным интерфейсом (файл динамической библиотеки плагина должен называться так: "название плагина".so);
        b. Реализуйте все 3 функции плагина:
            - init должна подключать call-back функцию executor_start_hook и писать в stdout "greeting initialized"
            - fini должна отключать executor_start_hook и писать в stdout "greeting finished"
            - name должна возвращать "greeting"
            Кастомная функция executor_start_hook должна писать в stdout "Hello, world!"
        c. Реализуйте модуль мастер процесса, способный загружать и выгружать плагины во время работы программы;
            Вызовите executor_start_hook в main. Для демонстрации работы подключите плагин с именем "greeting", пока hardcode.
    2. Написать статическую библиотеку конфига в соответсвии с интерфейсом:
        a. Реализуйте из него функцию (и только её) int create_config_table(void). Она должна просто возвращать ноль и не делать больше ничего.
    3. Написать динамическую библиотеку логгера в соответствии с интерфейсом:
        b. Реализуйте из него функцию (и только её) int init_logger(char* path, long file_size_limit, int files_limit).
            Она должна просто возвращать ноль и не делать больше ничего, реализовывать проверку аргументов пока не требуется.

## Ожидаемое поведение программы

### Обработка ошибок

 - Если *плагин* с требуемым именем файла *отсутствует*, то программа должна написать в stderr сообщение:<br><tab>
 <code>"Library couldn't be opened.\n \ <br>\tLibrary's path is %s\n \ <br>\tdlopen: %s\n \ <br>\tcheck plugins folder or rename library\n", ${путь_до_плагина}, ${сообщение_об_ошибке_от_dlopen}</code><br>
   очистить выделенные под плагин структуры и продолжить работу.
 - Если *функция* с требуемым именем *отсутствует в плагине*, то программа должна написать в stderr сообщение:<br>
  <code>"Library couldn't execute %s.\n \ <br>\tLibrary's name is %s. Dlsym message: %s\n \ <br>\tcheck plugins folder or rename library\n",${имя_функции}, ${имя_плагина}, ${ошибка_dlsym}</code><br>
 - Если *не удалось проинициализировать логгер* (код возврата init_logger = -1), то программа должна написать в stderr сообщение:<br>
  <code>"Failed to initialize the logger\n"</code><br> После этого завершить работу с кодом возврата 1.
 - Если *не удалось проинициализировать конфиг* (код возврата create_config_tables = -1), то программа должна написать в stderr сообщение:<br>
  <code>"Failed to initialize the config\n"</code><br> После этого завершить работу с кодом возврата 1.


## Архитектурные требования

    Для сборки нужно использовать Makefile и утилиту make. При этом необходимо настроить проброс переменнных окружения
    CCFLAGS, CFLAGS, COPT, CPPFLAGS, LDFLAGS. Это необходимо для того, чтобы система тестирования могла собрать проект с санитайзерами.

    Также необходимо указать следующие флаги компиляции -Wall -Wpedantic -Wpointer-arith -Wendif-labels -Wmissing-format-attribute -Wimplicit-fallthrough=3 -Wcast-function-type -Wshadow=compatible-local -Wformat-security. Это нужно для строгой проверки ошибок.

    Дерево каталогов должно иметь следующую структуру:

    root project directory
    |
    |
    ├── plugins
    │   └── greeting
    │       └── greeting.c
    |
    ├── README.md
    ├── src
    │   └── include
    │       ├── config.h
    │       ├── logger.h
    │       ├── master.h
    │       └── my_time.h
    |       └── и все прочие заголовочные файлы
    |
    |
    ├── install (эта директория генерируется при сборке проекта)
    |   ├── proxy (исполняемый файл)
    |   ├── все статические и динамические библиотеки со статической линковкой
    |   └── plugins
    |       └── greeting.so (название файла = "название плагина" + ".so")
    |
    ├── Makefile (Верхнеуровневый файл системы сборки)
    |
    └── tasks
        ├── introduction.md
        ├── lab1.md
        ├── lab2.md
        └── lab3.md


    Все собранные библитеки, плагины и исполняемый файл должны находиться в папке
    install в корневой дирректории проекта. При этом для плагинов в папке install должна быть создана отдельная папка plugins.
    Создание папок должно происходить автоматически при сборке проекта.

## Интерфейс и струтура проекта

    Весь необходимый итерфейс и структура проекта наглядно представлены в данной ветке
    (у каждого плагина обязательно должны быть функции: void init(void), void fini(void), const char *name(void)).

### Файл master.h
#### Типы:

| Название типа | метатип      | состав             |
| :------------ | :----------- | :----------------- |
| **Hook**      | **function** | **void(\*)(void)** |


#### Глобальные переменные:

| Тип      | префиксы   | Название                | Начальное значение |
| :------- | :--------- | :---------------------- | :----------------- |
| **Hook** | **extern** | **executor_start_hook** | **NULL**           |



### Файл logger.h

#### Функции:

<table>
    <thead>
        <tr>
            <th>Название</th>
            <th>Описание</th>
            <th>Аргументы</th>
            <th>Возвращаемое значение</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>init_logger</b></td>
            <td>Инициализирует логгер (его структуры данных)</td>
            <td>
                <b>[in] char* path</b> Путь до директории с файлами журнала от текущей рабочей директории. Может быть NULL, но тогда режим журналирования FILE будет не доступен<br>
                <b>[in] int file_size_limit</b> максимальный размер файла журнала в Кб (-1 означает бесконечность)<br>
                <b>[in] int files_limit</b> максимальное число файлов в директории (-1 означает бесконечность)
            </td>
            <td><b>int</b>, 0 в случае успеха, -1 иначе</td>
        </tr>
    </tbody>
</table>

### Файл config.h

#### Функции:


<table>
    <thead>
        <tr>
            <th style="text-align: left;">Название</th>
            <th style="text-align: left;">Описание</th>
            <th style="text-align: left;">Аргументы</th>
            <th style="text-align: left;">Возвращаемое значение</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td style="text-align: left;"><b>create_config_table</b></td>
            <td style="text-align: left;">Инициализирует структуры данных системы конфигурации</td>
            <td style="text-align: left;"><b>void</b></td>
            <td style="text-align: left;"><b>int</b>, -1 если система уже проинициализирована или произошла ошибка, 0 в случае успеха</td>
        </tr>
    </tbody>
</table>