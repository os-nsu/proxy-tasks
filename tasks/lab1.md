# Компиляция и линковка (lab1)

## Теоретические вопросы

1. Из каких этапов состоит компиляция (используйте флаги компилятора и посмотрите промежуточные результаты)?
1. Что такое `elf` файл и какие его типы бывают?
1. Используйте `readelf`. Посмотрите основные секции `elf` файла и их назначение.
1. Статические и динамические библиотеки. Чем отличаются `relocatable` и `shared object` файлы.
1. Различие статической и динамической линковки (посмотрите `dlopen` и `dlsym`).
1. `nm` и `ldd`, с какими секциями `elf` файла работают? Объяснить вывод.
1. Посмотрите зависимости собранного исполняемого файла. Зачем нужен `ld-linux.so` (секция `.interp`)?
1. Как запускается `main` функция программы?
1. При помощи `nm` посмотрите все символы получившегося исполняемого файла.

## Дополнительные вопросы

На эти вопросы вы можете найти ответы в представленной ниже литературе. Ответы на данные вопросы помогут вам лучше разобраться в теме.

1. Как именно происходит подключение символов из динамической библиотеки (секции `got`, `plt`)?
1. Что делает утилита `file`. Объяснить её вывод?
1. Чем отличаются секции от сегментов?
1. Зачем может понадобиться утилита `strip` и `objdump`?
1. Зачем нужен флаг компиляции `-export-dynamic`?
1. Как настроить компоновщик, чтобы сохранились все символы, предоставляемые статической библиотекой (даже не используемые в исполняемом файле)?


## Список литературы:
1. ["Мануал по системе сборки Make"](https://www.gnu.org/software/make/manual/make.html)
1. ["Практический анализ двоичных файлов" Дэннис Эндриесс](https://t.me/physics_lib/12341)
1. "SYSTEM V APPLICATION BINARY INTERFACE"
1. "Executable and Linking Format (ELF) Specification"


## Задания (порядок выполнения не важен)

1. Система плагинов:
    1. Напишите тестовый плагин с именем "greeting" в соответствии с представленным интерфейсом (файл динамической библиотеки плагина
    должен называться так: "название плагина".so);
    1. Реализуйте все 3 функции плагина:
        1. **init** должна переопределять глобальный внешний указатель executor_start_hook на свою реализацию
        и писать в stdout "greeting initialized". Это позволит в дальнейшем через глобальный указатель
        вызывать вашу реализацию executor_start_hook.
        Такая технология называется call-back функцией.
        Учтите, что **может быть несколько плагинов**, которые переопределяют указатель executor_start_hook.
        В этом случае должны вызваться все реализации.
        1. **fini** должна возвращать executor_start_hook в состояние, которым он обладал, до вызова init
        и писать в stdout "greeting finished"
        1. **name** должна возвращать "greeting"
        Ваша реализация executor_start_hook должна писать в stdout "Hello, world!"
    1. Напишите программу, способную загружать и выгружать плагины во время работы;
    	После загрузки должна вызываться функция init плагина, а непосредственно перед выгрузкой - fini.
        Вызовите executor_start_hook в main. Для демонстрации работы подключите плагин с именем "greeting", пока hardcode.
1. Написать статическую библиотеку конфига в соответствии с [интерфейсом](#файл-configh):
    1. Функции приведенные в интерфейсе должны пока только симулировать работу, так что функции не вызывает ошибок,
    при этом после первого вызова create_config_table считаем конфигурацию проинициализированной,
    и при следующей попытке запуска должны вернуть 1, так как двойная инициализация запрещена.
    Аналогично для destroy_config_table.
1. Написать динамическую библиотеку логгера в соответствии с [интерфейсом](#файл-loggerh):
    1. Функции приведенные в интерфейсе должны пока только симулировать работу, так что функции не вызывает ошибок,
    при этом после первого вызова init_logger считаем логгер проинициализированным,
    и при следующей попытке запуска должны вернуть 1, так как двойная инициализация запрещена.
    Аналогично для fini_logger.


## Ожидаемое поведение программы

> [!TIP]
> Ожидаемая от call-back функции логика работы - загрузить несколько плагинов, в мастере дернуть по указателю функцию,
>и чтобы по цепочке выполнились все определенные в плагинах реализации хуков. Для этого, например,
>можно определить в плагине глобальную переменную [типа](#типы) Hook, в init сохранять в неё значение [указателя на хук](#глобальные-переменные),
>после чего записать в [указатель на хук](#глобальные-переменные) указатель на свою функцию-хук. Тогда в последней можно будет сначала вызывать
>предыдущую функцию по значению из глобальной переменной плагина, а затем выполнять свою логику хука.
>P.S. вызов предыдущего хука в своём выполнять необходимо, без этого вся логика инициализации развалится
>(будет проинициализирована только часть плагинов, а то и вообще один)

### Обработка ошибок

1. Если *плагин* с требуемым именем файла *отсутствует*, то программа должна написать в stderr сообщение:
    ```C
    "Library couldn't be opened.\n \
    \tLibrary's path is %s\n \
    \tdlopen: %s\n \
    \tcheck plugins folder or rename library\n", ${путь_до_плагина}, ${сообщение_об_ошибке_от_dlopen}
    ```
    очистить выделенные под плагин структуры и завершить работу с кодом возврата 1.
1. Если *функция* с требуемым именем *отсутствует в плагине*, то программа должна написать в stderr сообщение:
    ```C
    "Library couldn't execute %s.\n \
    \tLibrary's name is %s. Dlsym message: %s\n \
    \tcheck plugins folder or rename library\n", ${имя_функции}, ${имя_плагина}, ${ошибка_dlsym}
    ```
    очистить выделенные под плагин структуры и завершить работу с кодом возврата 1.
1. Если *не удалось проинициализировать логгер* (код возврата init_logger = 1), то программа должна написать в stderr сообщение:
    ```C
    "Failed to initialize the logger\n"
    ```
    после этого завершить работу с кодом возврата 1.
1. Если *не удалось проинициализировать конфиг* (код возврата create_config_table = 1), то программа должна написать в stderr сообщение:
    ```C
    "Failed to initialize the config\n"
    ```
    после этого завершить работу с кодом возврата 1.
1. Если *не удалось освободить ресурсы логгера* (код возврата fini_logger = 1), то программа должна написать в stderr сообщение:
    ```C
    "Couldn't shut down logger\n"
    ```
    после этого завершить работу с кодом возврата 1.
1. Если *не удалось освободить ресурсы логгера* (код возврата destroy_config_table = 1), то программа должна написать в stderr сообщение:
    ```C
    "Couldn't shut down logger\n"
    ```
    после этого завершить работу с кодом возврата 1.


## Архитектурные требования

Для сборки нужно использовать Makefile и утилиту `make`. При этом необходимо настроить проброс переменных окружения
`CCFLAGS`, `CFLAGS`, `COPT`, `CPPFLAGS`, `LDFLAGS`. Это необходимо для того, чтобы система тестирования могла собрать проект
с санитайзерами.

> [!TIP]
> Под пробросом подразумевается дополнение пришедшей снаружи переменной окружения вашими значениями, по аналогии с export PATH=$PATH:/my/awesome/path

Также необходимо указать следующие флаги компиляции `-Wall -Wpedantic -Wpointer-arith -Wendif-labels -Wmissing-format-attribute -Wimplicit-fallthrough=3 -Wcast-function-type -Wshadow=compatible-local -Wformat-security`.
Это нужно для строгой проверки ошибок.

Дерево каталогов должно иметь следующую структуру:

    root project directory
    |
    |
    ├── plugins
    │   └── greeting
    │       └── greeting.c
    |
    ├── README.md
    ├── src
    │   └── include
    │       ├── config.h
    │       ├── logger.h
    │       ├── master.h
    │       └── my_time.h (появится во второй лабораторной работе)
    |       └── и все прочие заголовочные файлы
    |
    |
    ├── install (эта директория генерируется при сборке проекта)
    |   ├── proxy (исполняемый файл)
    |   ├── debug_proxy (появится во второй лабораторной)
    |   ├── все статические и динамические библиотеки со статической линковкой
    |   └── plugins
    |       └── greeting.so (название файла = "название плагина" + ".so")
    |
    ├── Makefile (Верхнеуровневый файл системы сборки)
    |
    └── tasks
        ├── lab1.md
        ├── lab2.md
        └── lab3.md


Все собранные библиотеки, плагины и исполняемый файл должны находиться в папке
install в корневой директории проекта. При этом для плагинов в папке install должна быть создана отдельная папка plugins.
Создание папок должно происходить автоматически при сборке проекта.

## Интерфейс и структура проекта

Весь необходимый интерфейс и структура проекта наглядно представлены в данной ветке
(у каждого плагина обязательно должны быть функции: void init(void), void fini(void), const char *name(void)).

### Файл master.h
#### Типы:

| Название типа | метатип      | состав             |
| :------------ | :----------- | :----------------- |
| **Hook**      | **function** | **void(\*)(void)** |


#### Глобальные переменные:

| Тип      | префиксы   | Название                | Начальное значение |
| :------- | :--------- | :---------------------- | :----------------- |
| **Hook** | **extern** | **executor_start_hook** | **NULL**           |



### Файл logger.h

#### Функции:

<table>
    <thead>
        <tr>
            <th>Название</th>
            <th>Описание</th>
            <th>Аргументы</th>
            <th>Возвращаемое значение</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>init_logger</b></td>
            <td>Инициализирует логгер (его структуры данных)</td>
            <td>
                <b>[in] char* path</b> Путь до файла журнала от текущей рабочей директории. Может быть NULL, но тогда режим журналирования FILE будет не доступен<br>
                <b>[in] int file_size_limit</b> максимальный размер файла журнала в Кб (-1 означает бесконечность)<br>
            </td>
            <td><b>int</b>, 0 в случае успеха, 1 иначе</td>
        </tr>
        <tr>
            <td><b>fini_logger</b></td>
            <td>Освобождает ресурсы логгера</td>
            <td>
                <b>void</b>
            </td>
            <td><b>int</b>, 0 в случае успеха, 1 если ресурсы логгера уже были освобождены</td>
        </tr>
    </tbody>
</table>

### Файл config.h

#### Функции:


<table>
    <thead>
        <tr>
            <th>Название</th>
            <th>Описание</th>
            <th>Аргументы</th>
            <th>Возвращаемое значение</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>create_config_table</b></td>
            <td>Инициализирует структуры данных системы конфигурации</td>
            <td><b>void</b></td>
            <td><b>int</b>, 1 если система уже проинициализирована или произошла ошибка, 0 в случае успеха</td>
        </tr>
        <tr>
            <td><b>destroy_config_table</b></td>
            <td>Освобождает все ресурсы, используемые системой конфигурации</td>
            <td><b>void</b></td>
            <td><b>int</b>, 1 если система уже освободила ресурсы или произошла ошибка, 0 в случае успеха</td>
        </tr>
    </tbody>
</table>
