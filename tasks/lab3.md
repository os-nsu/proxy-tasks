# Процессы (lab3)

## Теоретические вопросы

1. Что такое fork(2) и что он делает?
1. Что такое clone(2) и что он делает?
1. Состояния процесса. Состояние zombie и зачем оно нужно?
1. Как получить код возврата процесса и что этот код из себя представляет?
1. Что находится в proc, proc/stat?
1. Процесс init, зачем он нужен.
1. Что происходит с дочерними процессами, если родительский умирает?
1. Сигнал SIGCHLD. Зачем он нужен и в каких случаях приходит?

## Задания (порядок выполнения не важен)
1. Реализовать функцию void register_worker(...) в соответствии с интерфейсом.
    1. Эта функция должна создавать процесс, который начнёт выполнятся с переданной ему функции.
    1. Параметры, которые в неё передаются, должны быть где-то сохранены вместе с pid-ом процесса и
        удалены только при его окончательном завершении.
    1. Основной процесс должен посылать сигнал SIGTERM своим дочерним процессам при завершении.
        Коды возврата дочерних процессов должны корректно обрабатываться.
1. Написать плагин с названием task_manager, использующий функцию register_worker для создания процесса.
    1. Функция, которая будет запущена в новом процессе должна просто возвращать ноль.
    1. Напишите обработчик сигнала SIGTERM так, чтобы при получении этого сигнала код возврата был 0.

## Ожидаемое поведение программы

1. Если дочерний процесс завершился раньше завершения основного цикла программы, то поведение должно соответствовать
 значению параметра функции *register_worker* - **restart**, заданному при создании процесса.
1. При завершении основного цикла программы (даже если он был завершён некорректно, например по сигналу) нужно завершить все
 дочерние процессы, проанализировать код возврата каждого из них и освободить все связанные с ними ресурсы.

### Обработка ошибок

1. Если при работе функции *register_worker* **не получилось** создать новый процесс то необходимо
 написать в лог сообщение:
    ```
    "Can not create new worker's process for plugin: %s\n", ${имя_плагина_для_которого_создавался_процесс}.
    ```
    После этого необходимо освободить все вспомогательные ресурсы (такие как структуры), предназначенные для этого процесса и
    вернуть код -1.
    Основной цикл программы при этом не завершается и продолжает пытаться создать процессы для следующих плагинов.
1. Если при завершении основного цикла во время завершения дочерних процессов некоторые из них завершатся с кодом возврата,
отличным от нуля, или по сигналу то необходимо вывести в лог сообщение:
    ```
    "Worker's process %s with %d and finished with non zero code: %d\n", ${имя_процесса}, ${pid}, ${код_завершения} - в случае не нулевого кода,
    "Worker's process %s with %d and terminated by signal: %d\n", ${имя_процесса}, ${pid}, ${номер_сигнала} - в случае завершения по сигналу
    ```
    После этого основной процесс продолжает процедуру завершения работы остальных процессов.
1. Если при попытке перезапуска дочернего процесса произошла ошибка, то необходимо вывести в лог сообщение:
    ```
    "Can not start worker's process with pid: %d and name: %s", ${pid}, ${имя_процесса}
    ```
    При этом по попытки перезапустить процесс должны продолжаться с тем же таймаутом.
1. Если дочерний процесс завершился с ошибкой раньше основного цикла, то не зависимо от необходимости его перезапуска
 нужно вывести в лог сообщение:
    ```
    "Worker's process %s with %d finished with non zero code: %d\n", ${имя_процесса}, ${pid}, ${код_завершения} - в случае не нулевого кода,
    "Worker's process %s with %d terminated by signal: %d\n", ${имя_процесса}, ${pid}, ${номер_сигнала} - в случае завершения по сигналу
    ```

### Журнал сообщений

1. Если все операции по созданию процессов завершились успешно, то необходимо вывести в лог сообщение с уровнем LOG_INFO:
    ```
    "All worker's processes created successfully\n".
    ```
1. Если при завершении основного цикла все дочерние процессы завершились без ошибок, то необходимо вывести в лог сообщение с уровнем
 LOG_INFO:
    ```
    "All worker's processes terminated successfully\n".
    ```
1. Если дочерний процесс завершился с кодом ноль раньше основного цикла и при этом установлен перезапуск только в случае ошибки
 (IF_ERROR), то необходимо вывести в лог следующее сообщение:
    ```
    "Worker's process %s with %d finished successfully\n", ${имя_процесса}, ${pid}
    ```

## Требования к устойчивости

1. Все ресурсы при завершении должны корректно освобождаться (в том числе при сбоях в работе),
    дочерние процессы должны восстанавливаться если это необходимо, должна быть корректная обработка сигналов.

## Интерфейс и структура проекта

### Файл master.h

#### Типы:

<table>
  <thead>
    <tr>
      <th style="text-align: left;">Название типа</th>
      <th style="text-align: left;">Метатип</th>
      <th style="text-align: left;">Состав</th>
      <th style="text-align: left;">Описание</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left;"><b>RestartConstants</b></td>
      <td style="text-align: left;"><b>enum</b></td>
      <td style="text-align: left;">
        <b>NEVER</b> = 0 - Никогда не перезапускать<br>
        <b>ALWAYS</b> = 1 - Всегда пытаться перезапустить<br>
        <b>IF_ERROR</b> = 2 - Перезапускать если процесс завершился по сигналу или
            с кодом возврата, отличным от нуля
      </td>
      <td style="text-align: left;"><b>Определяет поведение при перезапуске процесса</b></td>
    </tr>
  </tbody>
</table>

#### Функции:

<table>
    <thead>
        <tr>
            <th>Название</th>
            <th>Описание</th>
            <th>Аргументы</th>
            <th>Возвращаемое значение</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>register_worker</b></td>
            <td>Создаёт новый процесс для плагина</td>
            <td>
                <b>[in] const char* name</b> Имя создаваемого процесса<br>
                <b>[in] const char* lib_name</b> Имя плагина (имя библиотеки) без ".so" в конце<br>
                <b>[in] const char* func_name</b> Точка входа для процесса (имя функции, с которой начнётся её выполнение)<br>
                <b>[in] RestartConstants restart</b> Определяет поведение при завершении этого процесса<br>
                <b>[in] uint32_t cooldown</b> В случае, если restart != NEVER определяет промежуток времени в секундах
                    через который процесс будет перезапущен
            </td>
            <td><b>void</td>
        </tr>
    </tbody>
</table>
